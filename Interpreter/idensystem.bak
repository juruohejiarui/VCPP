#include "vcppcpl.h"

namespace Interpreter {
#pragma region 一些全局变量
	//基本类型的Expression Type
	ExpressionType char_etype, int32_etype, int64_etype, uint64_etype, float64_etype, void_etype, object_etype;
	//基本类型的ClassInfo
	ClassInfo *char_cls, *int32_cls, *int64_cls, *uint64_cls, *float64_cls, *void_cls, *object_cls;

	NamespaceInfo *global_nsp;

	//加载的using列表
	vector<NamespaceInfo *> using_list;

	ulong global_memory_size;

	ulong GetGlobalMemorySize() { return global_memory_size; }

	inline bool IsInteger(ExpressionType &type) {
		return char_etype == type || int32_etype == type || int64_etype == type || uint64_etype == type;
	}
	inline bool IsFloat(ExpressionType &type) {
		return float64_etype == type;
	}
	bool IsBasicType(ExpressionType type) { 
		if (type.Dimc >= (TypeVarDimc >> 1)) type.Dimc = TypeVarDimc - type.Dimc;
		return IsInteger(type) || IsFloat(type); 
	}
	bool IsBasicClass(ClassInfo* cls) {
		return cls == char_cls || cls == int32_cls || cls == int64_cls || cls == uint64_cls || cls == float64_cls || cls == void_cls || cls == object_cls;
	}

	vector<NamespaceInfo *> usinglist;
	NamespaceInfo *cur_nsp;
	ClassInfo *cur_cls;
	FuncInfo *cur_func;

	void ClearUsing() {
		usinglist.clear();
	}
	int AddUsing(CplNode *using_nd) {
		auto plst = StringSplit(using_nd->Content.String, '@');
		auto nsp = global_nsp;
		for (int i = (plst[0] == "Global"); i < plst.size(); i++) {
			if (!nsp->Children.count(plst[i])) {
				PrintError("Can't find namespace : " + using_nd->Content.String);
				return -1;
			}
			nsp = nsp->Children[plst[i]];
		}
		usinglist.emplace_back(nsp);
		return 0;
	}
#pragma endregion

#pragma region Some Tool Functions 
	ExpressionType::ExpressionType(string type_name, int dimc, bool is_quote, bool is_member)
		: TypeName(type_name), Dimc(dimc), IsQuote(is_quote), IsMember(is_member) {
		Type = nullptr;
	}
	string ExpressionType::ToString() {
		string res = (Type != nullptr ? Type->FullName : TypeName);
		for (int i = 0; i < Dimc; i++) res.append("[]");
		if (IsQuote) res.append("&");
		return res;
	}
	string ExpressionType::ToIdenString() {
		return (Type != nullptr ? Type->FullName : TypeName) + "_Dimc" + std::to_string(Dimc);
	}
	bool ExpressionType::operator==(ExpressionType &b) {
		return Type == b.Type && Dimc == b.Dimc;
	}
	bool ExpressionType::operator!=(ExpressionType &b) {
		return Type != b.Type || Dimc != b.Dimc;
	}
	VarInfo::VarInfo() {
		Visibility = IdenVisibility::Private;
		Region = IdenRegion::Local;
		Addr = 0;
	}
	void VarFrame::Init(int total) {
		VarMap.clear();
		Total = total;
	}
	VarInfo *VarFrame::InsertVar(VarInfo &v_info) {
		VarMap[v_info.Name] = v_info;
		VarInfo *res = &VarMap[v_info.Name];
		res->Addr = Total++;
		return res;
	}

	VarFrame local_var_stack[256];
	int local_var_stack_size;
	const int local_var_stack_max_size = 256;

	void VarFrame::BuildCleanVasm() {
		for (auto &pair : VarMap) if (!IsBasicType(pair.second.Type)) {
			VasmBuilder_WriteCommand(povar, pair.second.Addr);
			VasmBuilder_WriteCommand(push, 0);
			VasmBuilder_WriteCommand(vomov);
		} else {
			VasmBuilder_WriteCommand(pvar, pair.second.Addr);
			VasmBuilder_WriteCommand(push, 0);
			VasmBuilder_WriteCommand(vi64mov);
		}
	}
	void LocalVarStack_Init() {
		local_var_stack[0].Previous = nullptr;
		local_var_stack[0].Init();
		local_var_stack_size = 0;
		for (int i = 1; i < local_var_stack_max_size; i++)
			local_var_stack[i].Previous = &local_var_stack[i - 1];
	}
	VarFrame *LocalVarStack_Top() { return &local_var_stack[local_var_stack_size - 1]; }
	void LocalVarStack_Pop(bool clean) {
		if (clean) LocalVarStack_Top()->BuildCleanVasm();
		local_var_stack_size--;
	}
	void LocalVarStack_Push() {
		local_var_stack[local_var_stack_size].Init(local_var_stack_size ? LocalVarStack_Top()->Total : 0);
		local_var_stack_size++;
	}

	FuncInfo::FuncInfo() {
		Visibility = IdenVisibility::Private;
		Region = IdenRegion::Global;
		Node = nullptr;
	}
	ClassInfo::ClassInfo() {
		Visibility = IdenVisibility::Private;
		Region = IdenRegion::Global;
		Parent = nullptr;
		Deep = 0;
		Size = 0;
		Status = ClassInfoStatus::Uncompleted;
	}
	VarInfo *ClassInfo::InsertVar(VarInfo v_info) {
		if (Var.count(v_info.Name)) return nullptr;
		VarInfo *res = Var[v_info.Name] = new VarInfo(v_info);
		res->Region = IdenRegion::Member;
		res->Type.IsMember = true;
		return res;
	}
	FuncInfo *ClassInfo::InsertFunc(FuncInfo f_info) {
		if (Func.count(f_info.Name)) return nullptr;
		FuncInfo *res = Func[f_info.Name] = new FuncInfo( f_info);
		res->Region = IdenRegion::Member;
		res->FullName = FullName + "@" + f_info.Name;
		return res;
	}
    NamespaceInfo::~NamespaceInfo() {
		for (auto &child : Children) delete child.second;
		for (auto &func : GlobalFunc) delete func.second;
		for (auto &var : GlobalVar) delete var.second;
		for (auto &cls : Class) delete cls.second;
    }
    int NamespaceInfo::Merge(NamespaceInfo source)
    {
        int res = 0;
		for (auto pair : source.Children) res |= (InsertChild(*(pair.second)) == nullptr);
		for (auto pair : source.GlobalFunc) res |= (InsertFunc(*(pair.second)) == nullptr);
		for (auto pair : source.Class) res != (InsertClass(*(pair.second)) == nullptr);
		return -res;
    }
    NamespaceInfo *NamespaceInfo::InsertChild(NamespaceInfo child) {
		if (Children.count(child.Name)) {
			int res = Children[child.Name]->Merge(child);
			if (res == -1) return nullptr;
			return Children[child.Name];
		}
		NamespaceInfo *res = Children[child.Name] = new NamespaceInfo(child);
		return res;
	}
	FuncInfo *NamespaceInfo::InsertFunc(FuncInfo f_info) {
		if (GlobalFunc.count(f_info.Name)) return nullptr;
		auto res = GlobalFunc[f_info.Name] = new FuncInfo(f_info);
		res->FullName = FullName + "@" + res->Name;
		res->Region = IdenRegion::Global;
		return res;
	}
	ClassInfo *NamespaceInfo::InsertClass(ClassInfo c_info) {
		if (GlobalFunc.count(c_info.Name)) return nullptr;
		auto res = Class[c_info.Name] = new ClassInfo(c_info);
		res->FullName = FullName + "@" + res->Name;
		return res;
	}
    VarInfo *NamespaceInfo::InsertVar(VarInfo v_info) {
		if (GlobalVar.count(v_info.Name)) return nullptr;
		auto res = GlobalVar[v_info.Name] = new VarInfo(v_info);
		res->FullName = FullName + "@" + res->Name;
		res->Region = IdenRegion::Global;
		return res;
    }
#pragma endregion

    void LoadBasicTypeInfo(ClassInfo *&c_info, ExpressionType &type, string name, int size) {
		ClassInfo temp;
		temp.Name = name, temp.Size = size, temp.Status = ClassInfoStatus::Completed;
		c_info = global_nsp->InsertClass(temp);
		c_info->Visibility = IdenVisibility::Public;
		type = ExpressionType(name);
		type.Type = c_info;
	}
	void IdenSystem_Init() {
		//load the infomation of basic type
		if (global_nsp != nullptr) delete global_nsp;
		global_nsp = new NamespaceInfo();
		global_nsp->Name = global_nsp->FullName = "Global";
		LoadBasicTypeInfo(object_cls, object_etype, "object", 8);
		LoadBasicTypeInfo(char_cls, char_etype, "char", 1);
		LoadBasicTypeInfo(int32_cls, int32_etype, "int", 4);
		LoadBasicTypeInfo(int64_cls, int64_etype, "long", 8);
		LoadBasicTypeInfo(uint64_cls, uint64_etype, "ulong", 8);
		LoadBasicTypeInfo(float64_cls, float64_etype, "float", 8);
		LoadBasicTypeInfo(void_cls, void_etype, "void", 0);

		global_memory_size = 0;
	}
#pragma region Tool Functions of IdenSystem_LoadDefinition()

	//create a namespace using the name(actually a path)
	NamespaceInfo *CreateNamespace(string name) {
		vector<string> lst = StringSplit(name, '@');
		NamespaceInfo *res = global_nsp; int st = 0;
		for (int i = (lst[0] == "Global"); i < lst.size(); i++) {
			if (!res->Children.count(lst[i])) {
				NamespaceInfo c;
				c.Name = lst[i], c.FullName = res->FullName + "@" + lst[i];
				res = res->InsertChild(c);
			} else res = res->Children[lst[i]];
		}
		return res;
	}
	ClassInfo *CreateClass(NamespaceInfo *nsp, string name) {
		if (nsp->Class.count(name)) return nsp->Class[name];
		ClassInfo tmp; tmp.Name = name;
		return nsp->InsertClass(tmp);
	}

#pragma region Search Process of class and global function
	ClassInfo *FindClass(string name, bool print_error = true) {
		//Remove the namespace path if class's full name include it
		if (name.length() > cur_nsp->FullName.length()
			 && name.substr(0, cur_nsp->FullName.length()) == cur_nsp->FullName)
			name = name.substr(cur_nsp->FullName.length() + 1);

		int t = 1, st = 0; bool fin = false;
		vector<string> path = StringSplit(name, '@');

		//start from the namespace Global
		NamespaceInfo *cur = global_nsp;
		//search the cur_nsp, it's valid to use private class
		if (cur_nsp->Children.count(path[0])) cur = cur_nsp;
		else if (cur_nsp->Class.count(path[0])) return cur_nsp->Class[path[0]];
		//search the usinglist, it's invalid to use private class
		else {
			t = 0;
			for (auto nsp : usinglist) {
				if (nsp->Children.count(path[0])) fin = true, cur = nsp;
				else if (nsp->Class.count(path[0]) && nsp->Class[path[0]]->Visibility == IdenVisibility::Public) 
					return nsp->Class[path[0]];
			}
		}
		//The only way is starting from Global
		if (!fin) st = (path[0] == "Global");

		for (int i = st; i < path.size() - 1; i++) {
			if (!cur->Children.count(path[i])) {
				if (print_error) PrintError("Can't find namespace : " + path[i]);
				return nullptr;
			}
			cur = cur->Children[path[i]];
		}
		string& cls = path[path.size() - 1];
		if (cur->Class.count(cls) && (t || cur->Class[cls]->Visibility == IdenVisibility::Public))
			return cur->Class[path[path.size() - 1]];
		else {
			if (print_error) PrintError("Can't find class : " + name);
			return nullptr;
		}
	}

	FuncInfo *FindGloablFunction(string name) {
		int t = 1, st = 0; bool fin = false;
		//Remove the namespace path if function's full name include it
		if (name.length() > cur_nsp->FullName.length()
			 && name.substr(0, cur_nsp->FullName.length()) == cur_nsp->FullName)
			name = name.substr(cur_nsp->FullName.length() + 1);

		vector<string> path = FuncNameSplit(name);
		//start from the namespace Global
		NamespaceInfo *cur = global_nsp;
		//search the cur_nsp, it's valid to use private function
		if (cur_nsp->Children.count(path[0])) fin = true, cur = cur_nsp;
		else if (cur_nsp->GlobalFunc.count(path[0])) return cur_nsp->GlobalFunc[path[0]];
		else {
			//search the usinglist, it's invalid to use private function
			t = 0;
			for (auto nsp : usinglist) {
				if (nsp->Children.count(path[0])) fin = true, cur = nsp;
				else if (nsp->GlobalFunc.count(path[0]) && nsp->GlobalFunc[path[0]]->Visibility == IdenVisibility::Public) 
					return nsp->GlobalFunc[path[0]];
			}
		}
		
		//The only way is starting from Global
		if (!fin) st = (path[0] == "Global");
		//search along the path
		for (int i = st; i < path.size() - 1; i++) {
			if (!cur->Children.count(path[i])) {
				PrintError("Can't find namespace : " + path[i]);
				return nullptr;
			}
			cur = cur->Children[path[i]];
		}
		auto &func = path[path.size() - 1];
		//Search the cur
		if (cur->GlobalFunc.count(func) && (t || cur->GlobalFunc[func]->Visibility == IdenVisibility::Public))
			return cur->GlobalFunc[func];
		else return nullptr;
	}
	/// @brief Search the global variable named NAME
	/// @param name 
	/// @return 
	VarInfo *FindGlobalVariable(string name) {
		int t = 1, st = 0; bool fin = false;
		//Remove the namespace path if variable's full name include it
		if (name.length() > cur_nsp->FullName.length()
			 && name.substr(0, cur_nsp->FullName.length()) == cur_nsp->FullName)
			name = name.substr(cur_nsp->FullName.length() + 1);
		
		vector<string> path = StringSplit(name, '@');
		NamespaceInfo *cur = global_nsp;
		if (cur_nsp->Children.count(path[0])) fin = true, cur = cur_nsp;
		else if (cur_nsp->GlobalVar.count(path[0])) return cur_nsp->GlobalVar[path[0]];
		else {
			//search the usinglist, it's invalid to use private variable
			t = 0;
			for (auto nsp : usinglist) {
				if (nsp->Children.count(path[0])) fin = true, cur = nsp;
				else if (nsp->GlobalVar.count(path[0]) && nsp->GlobalVar[path[0]]->Visibility == IdenVisibility::Public)
					return nsp->GlobalVar[path[0]];
			}
		}
		//The only way is starting from Global
		if (!fin) st = (path[0] == "Global");
		//search along the path
		for (int i = st; i < path.size() - 1; i++) {
			if (!cur->Children.count(path[i])) {
				PrintError("Can't find namespace : " + path[i]);
				return nullptr;
			}
			cur = cur->Children[path[i]];
		}
		auto &var_name = path[path.size() - 1];
		
		if (cur->GlobalVar.count(var_name) && (t || cur->GlobalVar[var_name]->Visibility == IdenVisibility::Public))
			return cur->GlobalVar[var_name];
		else return nullptr;
	}
#pragma endregion
	
	inline IdenVisibility GetIdenVisibility(TokenType tkt) { 
		return (IdenVisibility)((int)IdenVisibility::Private + (int)tkt - (int)TokenType::Private); 
	}
	
	/// @brief build the infomation of global function
	/// @param nsp the namespace this function belongs to
	/// @param f_node the CplNode
	/// @return If it's successful
	int BuildGlobalFunction(NamespaceInfo *nsp, CplNode *f_node) {
		FuncInfo tmp, *func; 
		int res = 0;
		tmp.Visibility = GetIdenVisibility(f_node->Content.Type);
		tmp.Node = f_node;
		f_node->ExprType.Type = FindClass(f_node->ExprType.TypeName);
		if (f_node->ExprType.Type == nullptr) res = -1;
		tmp.ResultType = f_node->ExprType;

		//build the argument's expression type identifier
		for (int i = 0; i < f_node->Children.size() - 1; i++) {
			auto &arg_t = f_node->At(i)->ExprType;
			arg_t.Type = FindClass(arg_t.TypeName);
			arg_t.IsQuote = true;
			if (arg_t.Type == nullptr) res = -1;
			f_node->Content.String.push_back('.');
			f_node->Content.String.append(arg_t.ToIdenString());
		}
		tmp.Name = f_node->Content.String;
		func = nsp->InsertFunc(tmp);
		func->Region = IdenRegion::Global;
		f_node->Content.String = func->FullName;
		return res;
	}

	int BuildGlobalVariable(NamespaceInfo *nsp, CplNode *v_node) {
		int res = 0;
		VarInfo tmpl;
		tmpl.Visibility = GetIdenVisibility(v_node->Content.Type);
		v_node->ExprType.Type = FindClass(v_node->ExprType.TypeName);
		if (v_node->ExprType.Type == nullptr) res = -1;
		tmpl.Type = v_node->ExprType;

		for (int i = 0; i < v_node->Children.size(); i += 2) {
			string var_name = v_node->At(i)->Content.String;
			VarInfo tmp = tmpl, *v_info;
			tmp.Name = var_name;
			v_info = nsp->InsertVar(tmp);
			v_info->Addr = global_memory_size;
			global_memory_size += sizeof(ulong);
		}
		return res;
	}

#pragma region __init__ and the member function
	// build the __init__() of cls which belongs to nsp
	int BuildInitFunction(NamespaceInfo *nsp, ClassInfo *cls, CplNode *f_node) {
		FuncInfo tmp, *func; 
		int res = 0;
		tmp.Name = cls->Name;
		//the visibility of __init__() must be public
		tmp.Visibility = IdenVisibility::Public;
		f_node->Content.Type = TokenType::Public;
		for (int i = 0; i < f_node->Children.size() - 1; i++) {
			auto &arg_t = f_node->At(i)->ExprType;
			arg_t.Type = FindClass(arg_t.TypeName);
			if (arg_t.Type == nullptr) res = -1;
			tmp.Name.push_back('.');
			tmp.Name.append(arg_t.ToIdenString());
		}
		func = nsp->InsertFunc(tmp);
		func->ResultType = ExpressionType(cls->FullName);
		func->ResultType.Type = cls;
		func->Region = IdenRegion::Member;
		func->Node = f_node;
		f_node->ExprType = func->ResultType;
		f_node->Content.String = func->FullName;
		//build the definition of this
		CplNode *cont_nd = f_node->At(f_node->Children.size() - 1);
		{
			CplNode* def_nd = new CplNode(CplNodeType::VarDefine),
				*var_def = new CplNode(CplNodeType::Identifier),
				*init_expr = new CplNode(CplNodeType::Expression),
				*var_call = new CplNode(CplNodeType::Identifier),
				*ass = new CplNode(CplNodeType::Assign);
			def_nd->ExprType = ExpressionType(cls->FullName, 0, true, 0);
			def_nd->AddChild(var_def), def_nd->AddChild(init_expr);
			init_expr->AddChild(ass), ass->AddChild(var_call);
			var_def->Content.String = var_call->Content.String = "this";
			def_nd->LocalVarCount = 1; f_node->LocalVarCount++;
			//use the "super()"
			if (cont_nd->Children.size() > 0 && cont_nd->At(0)->Type == CplNodeType::Super) {
				//the code of this tree is for type this = super(args)
				CplNode *sup = cont_nd->At(0),
					*as = new CplNode(CplNodeType::As), *t_nd = new CplNode(CplNodeType::Identifier);
				t_nd->Content.String = cls->FullName;
				sup->Type = CplNodeType::FuncCall;
				sup->Content.String = "super";
				as->AddChild(sup), as->AddChild(t_nd), ass->AddChild(as);
				cont_nd->ChangeChild(0, def_nd);
			} else {
				//the code of this tree is for type this = $type
				CplNode *new_nd = new CplNode(CplNodeType::New), *t_nd = new CplNode(CplNodeType::Identifier);
				t_nd->Content.String = cls->FullName;
				new_nd->AddChild(t_nd), ass->AddChild(new_nd);
				cont_nd->InsertChild(0, def_nd);
			}
		}
		//append "return this;"
		auto gen_ret = [&cls]() ->CplNode * {
			CplNode *ret = new CplNode(CplNodeType::Return),
				*expr = new CplNode(CplNodeType::Expression),
				*this_var = new CplNode(CplNodeType::Identifier);
			this_var->Content.String = "this";
			this_var->ExprType = ExpressionType(cls->FullName, 0, true);
			expr->AddChild(this_var);
			ret->AddChild(expr);
			return ret;
		};
		cont_nd->AddChild(gen_ret());

		return res;
	}
	// build the infomation of a member function in cls
	int BuildMemberFunction(ClassInfo *cls, CplNode *f_node) {
		FuncInfo tmp, *func;
		int res = 0;
		tmp.Name = f_node->Content.String;
		tmp.Visibility = GetIdenVisibility(f_node->Content.Type);
		for (int i = 0; i < f_node->Children.size() - 1; i++) {
			auto &arg_t = f_node->At(i)->ExprType;
			arg_t.Type = FindClass(arg_t.TypeName);
			if (arg_t.Type == nullptr) res = -1;
			tmp.Name.push_back('.');
			tmp.Name.append(arg_t.ToIdenString());
		}
		func = cls->InsertFunc(tmp);
		func->Region = IdenRegion::Member;
		func->Node = f_node;
		f_node->LocalVarCount++;
		f_node->ExprType.Type = FindClass(f_node->ExprType.TypeName);
		func->ResultType = f_node->ExprType;
		f_node->Content.String = func->FullName;

		//add the argument "this"
		auto gen_this = [&cls]() -> CplNode* {
			CplNode* var = new CplNode(CplNodeType::Identifier);
			var->ExprType = ExpressionType(cls->FullName, 0, true);
			var->ExprType.Type = cls;
			var->Content.String = "this";
			return var;
		};
		f_node->InsertChild(0, gen_this());
		f_node->LocalVarCount++;
		return res;
	}
#pragma endregion
	
	//build the content of the class, with the node
	int BuildClass(ClassInfo *cls, CplNode *node) {
		cur_cls = cls;
		cls->Visibility = GetIdenVisibility(node->Content.Type);
		cls->Region = IdenRegion::Global;
		CplNode *pre_iden = node->At(0);
		ClassInfo *par = FindClass(pre_iden->Content.String);
		int res = 0;
		if (par == nullptr) res = -1;
		cls->Parent = par;
		//set the parent of cls
		par->Children.emplace_back(cls);

		//build the member variables of cls
		for (int i = 1; i < node->Children.size(); i++) {
			CplNode *child = node->At(i);
			if (child->Type == CplNodeType::VarDefine) {
				child->ExprType.Type = FindClass(child->ExprType.TypeName);
				ExpressionType vtype = child->ExprType;
				if (vtype.Type == nullptr) res = -1;
				child->ExprType = vtype;
				for (int i = 0; i < child->Children.size(); i += 2) {
					CplNode *vnd = child->At(i);
					VarInfo mem; 
					mem.Name = vnd->Content.String;
					mem.FullName = vnd->Content.String = cls->FullName + "@" + mem.Name;
					mem.Region = IdenRegion::Member;
					mem.Type = vtype;
					mem.Visibility = GetIdenVisibility(child->Content.Type);
					mem.Node = vnd;
					cls->InsertVar(mem);
				}
			}
		}
		//build the member functions and __init__() of cls
		for (int i = 1; i < node->Children.size(); i++) {
			CplNode *child = node->At(i);
			if (child->Type != CplNodeType::FuncDefine) continue;
			if (child->Content.String == "__init__") 
				res |= BuildInitFunction(cur_nsp, cls, child);
			else res |= BuildMemberFunction(cls, child);
		}
		cur_cls = nullptr;
		return res;
	}

	//build the identifier of a class with node
	int BuildClassIdentifier(CplNode *node) {
		string nsp_name = node->Content.String;
		auto nsp = CreateNamespace(nsp_name);
		for (auto child : node->Children) if (child->Type == CplNodeType::ClassDefine) {
			ClassInfo *cls = CreateClass(nsp, child->Content.String);
			cls->Visibility = GetIdenVisibility(child->Content.Type);
			cls->Node.emplace_back(child);
		}
		return 0;
	}
	//build the definition of variable, functions and class
	int BuildDefinition(CplNode *node, NamespaceInfo *nsp) {
		int res = 0;
		cur_nsp = nsp;
		for (CplNode *mem : node->Children) {
			switch (mem->Type) {
				case CplNodeType::VarDefine:
					res |= BuildGlobalVariable(nsp, mem);
					break;
				case CplNodeType::FuncDefine:
					res |= BuildGlobalFunction(nsp, mem);
					break;
				case CplNodeType::ClassDefine:
					res |= BuildClass(nsp->Class[mem->Content.String], mem);
					break;
			}
		}
		cur_nsp = nullptr;
		return res;
	}

	//build the class tree
	int BuildClassTree(ClassInfo* cls) {
		cls->Status = ClassInfoStatus::Completed;
		int res = 0;
		for (auto child : cls->Children) {
			if (child->Status == ClassInfoStatus::Completed) continue;
			child->Deep = cls->Deep + 1;
			child->Size = cls->Size;
			//calculate the size of class
			for (auto &mem : child->Var) {
				auto &var = mem.second;
				var->Addr = child->Size;
				child->Size += sizeof(ulong);
			}
			//inherit the variables of class
			for (auto &mem : cls->Var) {
				auto &var = mem.second;
				if (var->Visibility == IdenVisibility::Private
					|| child->Var.count(mem.first)) continue;
				child->Var.insert(mem);
			}
			//inherit the functions of class
			for (auto &mem : cls->Func) {
				auto func = mem.second; 
				//check the visibility of parent's functions and avoid overriding
				if (func->Visibility == IdenVisibility::Private
					|| child->Func.count(mem.first)) continue;
				child->Func.insert(make_pair(mem.first, mem.second));
			}
			res |= BuildClassTree(child);
		}
		return res;
	}
#ifdef DEBUG_MODULE 

	void PrintClassInfo(ClassInfo *cls, int dep, bool print_content = false) {
		for (int i = 0; i < dep; i++) printf("    ");
		PrintLog(cls->Name + " >> " + cls->FullName + "\n", FOREGROUND_WHITE | FOREGROUND_INTENSITY);
		if (!print_content) return ;
		for (auto &var : cls->Var) {
			for (int i = 0; i <= dep; i++) printf("    ");
			PrintLog(var.second->Type.ToString() + " ", FOREGROUND_GREEN | FOREGROUND_INTENSITY);
			PrintLog(var.first + "\n", FOREGROUND_WHITE);
		}
		for (auto &func : cls->Func) {
			for (int i = 0; i <= dep; i++) printf("    ");
			PrintLog(func.first + " >> ", FOREGROUND_WHITE);
			PrintLog(func.second->ResultType.ToIdenString() + " ", FOREGROUND_RED | FOREGROUND_INTENSITY);
			vector<string> part = StringSplit(func.second->FullName, '.');
			
			PrintLog(part[0] + "(", FOREGROUND_INTENSITY | FOREGROUND_WHITE);
			if (part.size() > 1) for (int i = 1; i < part.size(); i++) {
				PrintLog(part[i], FOREGROUND_WHITE);
				if (i < part.size() - 1) PrintLog(",", FOREGROUND_WHITE);
				else PrintLog(")\n", FOREGROUND_WHITE | FOREGROUND_INTENSITY);
			} else PrintLog(")\n", FOREGROUND_WHITE | FOREGROUND_INTENSITY);
		}
	}
	void PrintClassTree(ClassInfo* cls, int dep) {
		PrintClassInfo(cls, dep, true);
		for (auto &child : cls->Children) {
			PrintClassTree(child, dep + 1);
		}
	}
	void PrintNamespaceTree(NamespaceInfo *nsp, int dep) {
		for (int i = 0; i < dep; i++) printf("    ");
		PrintLog(nsp->Name, FOREGROUND_GREEN);
		PrintLog(" " + nsp->FullName + "\n", FOREGROUND_WHITE);
		for (auto &cls : nsp->Class) PrintClassInfo(cls.second, dep + 1);
		for (auto &cls : nsp->GlobalFunc) {
			for (int i = 0; i <= dep; i++) printf("    ");

			PrintLog(cls.first + " >> ", FOREGROUND_WHITE);
			PrintLog(cls.second->ResultType.ToIdenString() + " ", FOREGROUND_RED | FOREGROUND_INTENSITY);
			PrintLog(cls.second->FullName + "\n", FOREGROUND_WHITE | FOREGROUND_INTENSITY);
		}
		for (auto &nsp : nsp->Children)
			PrintNamespaceTree(nsp.second, dep + 1);
			
	}
#endif
#pragma endregion

#pragma region Tool Functions of IdenSystem_ExpressionType()
	
#pragma region Expression
	int BuildExpressionEType(CplNode *&node);

	ExpressionType GetOperResultType(ExpressionType& a, ExpressionType& b) {
		if (a == float64_etype || b == float64_etype) return float64_etype;
		else if (a == uint64_etype || b == uint64_etype) return uint64_etype;
		else if (a == int64_etype || b == int64_etype) return int64_etype;
		else if (a == int32_etype || b == int32_etype) return int32_etype;
		return char_etype;
	}
	int BuildFunctionCall(CplNode* node, string& iden, ClassInfo* cls = nullptr) {
		int res = 0;
		iden = node->Content.String;
		for (auto &arg : node->Children) {
			res |= BuildExpressionEType(arg);
			iden.push_back('.'), iden.append(arg->ExprType.ToIdenString());
		}
		return res;
	}
	//Identify a identifier
	int Identify(CplNode *&node) {
		bool succ = false, is_func = false; int res = 0;
		string iden;
		//Get the fullname
		if (node->Type == CplNodeType::Region) {
			iden.clear();
			vector<string> lst;
			auto cur = node;
			if (cur->At(1)->Type == CplNodeType::FuncCall) {
				lst.emplace_back("");
				res |= BuildFunctionCall(cur->At(1), lst[0]);
				is_func = true;
			} else lst.emplace_back(cur->At(1)->Content.String);
			for (cur = cur->At(0); cur->Type == CplNodeType::Region; cur = cur->At(0))
				lst.emplace_back(cur->At(1)->Content.String);
			lst.emplace_back(cur->Content.String);
			reverse(lst.begin(), lst.end());
			for (auto &part : lst) iden.append(part);
		} else if (node->Type == CplNodeType::FuncCall) {
			//replace the "super" with the fullname of the cur_cls
			if (node->Content.String == "super") 
				node->Content.String = cur_cls->Parent->FullName;
			res |= BuildFunctionCall(node, iden), is_func = true;
		} else iden = node->Content.String;
		node->Content.String = iden;
		//search the identifier of local variable stack
		for (auto frm = LocalVarStack_Top(); frm != nullptr; frm = frm->Previous)
			if (frm->VarMap.count(iden)) {
				succ = true;
				auto &vinfo = frm->VarMap[iden];
				node->ExprType = vinfo.Type;
				//Use the Content.Ulong to store the variable's ID
				node->Content.Ulong = vinfo.Addr;
				//Set the Flag, and store it into the Content.Char
				node->Content.Char = 0;
				break;
			}
		//try to find this name in the class
		if (!succ) {
			//generate "this.xxx"
			auto gen_this = [&res](CplNode *node) -> CplNode * {
				CplNode *callmem = new CplNode(CplNodeType::CallMember);
				CplNode *call_this = new CplNode(CplNodeType::Identifier);
				call_this->Content.String = "this";
				res |= Identify(call_this);
				callmem->AddChild(call_this), callmem->AddChild(node);
				return callmem;
			};
			if (cur_cls != nullptr) {
				if (is_func && cur_cls->Func.count(iden))
					node = gen_this(node), succ = true,
					node->ExprType = cur_cls->Func[iden]->ResultType,

					node->Content.String = node->At(0)->ExprType.Type->FullName + "@" + iden;
				else if (!is_func && cur_cls->Var.count(iden))
					node = gen_this(node), succ = true,
					node->ExprType = cur_cls->Var[iden]->Type,

					node->Content.Ulong = cur_cls->Var[iden]->Addr;
			}
		}
		//search the identifier in Global
		if (!succ) {
			if (is_func) {
				auto func = FindGloablFunction(iden);
				if (func == nullptr) {
					PrintError("Can't find func : " + iden, node->Content.Line);
					node->Type = CplNodeType::Error;
					res = -1;
				} else node->ExprType = func->ResultType, node->Content.String = func->FullName;
			} else {
				auto cls = FindClass(iden, false);
				if (cls != nullptr) {
					node->ExprType = ExpressionType(cls->FullName, TypeVarDimc);
					node->ExprType.Type = cls, node->Content.String = cls->FullName;
				} else {
					//Try to find the identifier in the global variable list
					auto v_info = FindGlobalVariable(iden);
					if (v_info != nullptr) {
						node->ExprType = v_info->Type;
						node->Content.Ulong = v_info->Addr;
						// Set the flag
						node->Content.Char = 1;
					} else {
						PrintError("Can't find the identifier :" + iden, node->Content.Line);
						node->Type = CplNodeType::Error;
						return -1;
					}
				}
			}
		} 
		return res;
	}
	int BuildExpressionEType(CplNode *&node) {
		int res = 0;
		
		switch (node->Type) {
			case CplNodeType::Empty: node->ExprType = void_etype; break;
			case CplNodeType::Integer:
				node->ExprType = int32_etype;
				break;
			case CplNodeType::Char:
				node->ExprType = char_etype;
				break;
			case CplNodeType::Float:
				node->ExprType = float64_etype;
				break;
			case CplNodeType::String:
				node->ExprType = ExpressionType("Global@char", 1);
				node->ExprType.Type = char_cls;
				break;
			case CplNodeType::Comma:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				node->ExprType = node->At(1)->ExprType;
				break;
			case CplNodeType::Assign:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (node->At(0)->ExprType != node->At(1)->ExprType
					|| node->At(0)->ExprType.IsQuote == false) {
					PrintError("Invalid value of operator = ", node->Content.Line);
					res = -1;
				}
				node->ExprType = void_etype;
				break;
			case CplNodeType::New:
				res |= BuildExpressionEType(node->At(0));
				if (node->At(0)->ExprType.Dimc < (TypeVarDimc >> 1))
					PrintError("The value of $ must a type indentifier.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else
					node->ExprType = node->At(0)->ExprType,
					node->ExprType.Dimc = TypeVarDimc - node->ExprType.Dimc;
				break;
			case CplNodeType::ArrIndex:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (node->At(1)->Type == CplNodeType::Empty || IsInteger(node->At(1)->ExprType))
					node->ExprType = node->At(0)->ExprType, node->ExprType.Dimc--, node->ExprType.IsMember = true;
				else {
					PrintError("The Index of [] must be an integer.", node->Content.Line);
					node->Type = CplNodeType::Error, res = -1;
				}
				break;
			case CplNodeType::Add:
			case CplNodeType::Minus:
			case CplNodeType::Mul:
			case CplNodeType::Divison:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (!IsBasicType(node->At(0)->ExprType) || !IsBasicType(node->At(1)->ExprType))
					PrintError("The value of + - * / must be number.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else node->ExprType = GetOperResultType(node->At(0)->ExprType, node->At(1)->ExprType);
				break;
			case CplNodeType::Mod:
			case CplNodeType::BitAnd:
			case CplNodeType::BitOr:
			case CplNodeType::BitXor:
			case CplNodeType::Lmov:
			case CplNodeType::Rmov:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (!IsInteger(node->At(0)->ExprType) || !IsInteger(node->At(1)->ExprType))
					PrintError("The value of % & | ^ << >> must be integer.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else node->ExprType = GetOperResultType(node->At(0)->ExprType, node->At(1)->ExprType);
				break;
			case CplNodeType::Le:
			case CplNodeType::Ls:
			case CplNodeType::Ge:
			case CplNodeType::Gt:
			case CplNodeType::Equ:
			case CplNodeType::Neq:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (!IsBasicType(node->At(0)->ExprType) || !IsBasicType(node->At(1)->ExprType))
					PrintError("The value of < <= > >= == != must be number.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else node->ExprType = int32_etype;
				break;
			case CplNodeType::LogicAnd:
			case CplNodeType::LogicOr:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				node->ExprType = int32_etype;
				break;
			case CplNodeType::BitNot:
				res |= BuildExpressionEType(node->At(0));
				if (!IsInteger(node->At(0)->ExprType))
					PrintError("The value of ~ must be integer.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else
					node->ExprType = node->At(0)->ExprType,
					node->ExprType.IsMember = node->ExprType.IsQuote = false;
				break;
			case CplNodeType::LogicNot:
				res |= BuildExpressionEType(node->At(0));
				if (!IsInteger(node->At(0)->ExprType))
					PrintError("The value of ~ must be integer.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				else node->ExprType = int32_etype;
				break;
			case CplNodeType::As:
				res |= BuildExpressionEType(node->At(0)) | BuildExpressionEType(node->At(1));
				if (node->At(1)->ExprType.Dimc <= (TypeVarDimc >> 1))
					PrintError("The right value of => must a type indentifier.", node->Content.Line),
					node->Type = CplNodeType::Error, res = -1;
				node->ExprType = node->At(1)->ExprType;
				node->ExprType.Dimc = TypeVarDimc - node->ExprType.Dimc;
				node->ExprType.IsMember = node->At(0)->ExprType.IsMember;
				node->ExprType.IsQuote = node->At(0)->ExprType.IsQuote;
				if (IsBasicType(node->At(0)->ExprType) != IsBasicType(node->At(1)->ExprType))
					node->ExprType.IsMember = node->ExprType.IsQuote = false;
				break;
			case CplNodeType::Region:
			case CplNodeType::Identifier:
			case CplNodeType::FuncCall:
				res |= Identify(node);
				break;
			case CplNodeType::CallMember:
				res |= BuildExpressionEType(node->At(0));
				if (res != -1 && !node->At(0)->ExprType.Dimc) {
					string iden; auto cls = node->At(0)->ExprType.Type;
					bool is_this = (node->At(0)->Type == CplNodeType::Identifier && node->At(0)->Content.String == "this");
					if (node->At(1)->Type == CplNodeType::FuncCall) {
						res |= BuildFunctionCall(node->At(1), iden);
						if (cls->Func.count(iden) && (is_this || cls->Func[iden]->Visibility == IdenVisibility::Public)) 
							node->ExprType = cls->Func[iden]->ResultType, 
							node->Content.String = cls->Func[iden]->FullName;
						else {
							PrintError("Can't find func : " + node->At(0)->ExprType.ToString() + "@" + iden, node->Content.Line);
							node->Type = CplNodeType::Error, res = -1;
						}
					} else {
						iden = node->At(1)->Content.String;
						if (cls->Var.count(iden) && (is_this || cls->Var[iden]->Visibility == IdenVisibility::Public)) 
							node->ExprType = cls->Var[iden]->Type, node->Content.Ulong = cls->Var[iden]->Addr;
						else {
							PrintError("Can't find member : " + node->At(0)->ExprType.Type->FullName + "@" + iden, node->Content.Line);
							node->Type = CplNodeType::Error, res = -1;
						}
					}

				} else { PrintError("Invalid Value of operator .", node->At(0)->Content.Line), res = -1; }
				break;
			case CplNodeType::Expression:
				res |= BuildExpressionEType(node->At(0)), node->ExprType = node->At(0)->ExprType;
				break;
		}
		return res;
	}
#pragma endregion
	int BuildNodeEType(CplNode *&nd);

	int BuildIfEType(CplNode *node) {
		int res = BuildExpressionEType(node->At(0));
		if (!IsBasicType(node->At(0)->ExprType)) {
			PrintError("The condition expression must be number.", node->At(0)->Content.Line);
			res = -1, node->Type = CplNodeType::Error;
		}
		res |= BuildNodeEType(node->At(1)) | (node->Children.size() > 2 ? BuildNodeEType(node->At(2)) : 0);
		return res;
	}
	int BuildWhileEType(CplNode *node) {
		int res = BuildExpressionEType(node->At(0));
		if (!IsBasicType(node->At(0)->ExprType)) {
			PrintError("The condition expression must be number.", node->At(0)->Content.Line);
			res = -1, node->Type = CplNodeType::Error;
		}
		res |= BuildNodeEType(node->At(1));
		return res;
	}
	int BuildForEType(CplNode *node) {
		LocalVarStack_Push();
		int res = BuildNodeEType(node->At(0));
		res |= BuildExpressionEType(node->At(1));
		if (node->At(1) != nullptr && !IsBasicType(node->At(1)->ExprType)) {
			PrintError("The condition expression must be number.", node->At(0)->Content.Line);
			res = -1, node->Type = CplNodeType::Error;
		}
		res |= BuildExpressionEType(node->At(2)) | BuildNodeEType(node->At(3));
		LocalVarStack_Pop();
		return 0;
	}
	int BuildReturnEType(CplNode *node) {
		ExpressionType ret = void_etype;
		int res = 0;
		if (node->Children.size()) res |= BuildExpressionEType(node->At(0)), ret = node->At(0)->ExprType;
		if (ret != cur_func->ResultType) {
			PrintError("The expression type of return is not match the expression type of function" + cur_func->FullName, node->Content.Line);
			res = -1, node->Type = CplNodeType::Error;
		}
		return res;
	}

	int BuildSingleVarDef(CplNode *iden, ExpressionType* vtype = nullptr) {
		auto frm = LocalVarStack_Top();
		int res = 0;
		if (frm->VarMap.count(iden->Content.String)) {
			PrintError("Multiple definition of identifier : " + iden->Content.String, iden->Content.Line);
			iden->Type = CplNodeType::Error, res = -1;
		}
		VarInfo vinfo;
		vinfo.Name = iden->Content.String, vinfo.Region = IdenRegion::Local;
		if (vtype != nullptr) vinfo.Type = *vtype;
		else vinfo.Type = iden->ExprType;
		frm->InsertVar(vinfo);
		return res;
	}
	int BuildVarDefEType(CplNode *node) {
		int res = 0;
		auto &vtype = node->ExprType;
		vtype.Type = FindClass(vtype.TypeName);
		if (vtype.Type == nullptr) { PrintError("Can't find the type : " + vtype.TypeName, node->Content.Line), res = -1; }
		auto frm = LocalVarStack_Top();
		vtype.IsQuote = true, vtype.IsMember = 0;
		for (int i = 0; i < node->Children.size(); i += 2) {
			auto &iden = node->At(i), &expr = node->At(i + 1);
			res |= BuildSingleVarDef(iden, &vtype) | BuildExpressionEType(expr);
		}
		return res;
	}
	int BuildBlockEType(CplNode *node) {
		LocalVarStack_Push();
		int res = 0;
		for (auto child : node->Children) res |= BuildNodeEType(child);
		LocalVarStack_Pop();
		return res;
	}

	int BuildNodeEType(CplNode *&node) {
		int res = 0;
		switch (node->Type) {
			case CplNodeType::Block: res = BuildBlockEType(node); break;
			case CplNodeType::Expression: res = BuildExpressionEType(node); break;
			case CplNodeType::VarDefine: res = BuildVarDefEType(node); break;
			case CplNodeType::If: res = BuildIfEType(node); break;
			case CplNodeType::While: res = BuildWhileEType(node); break;
			case CplNodeType::For: res = BuildForEType(node); break;
			case CplNodeType::Return: res = BuildReturnEType(node); break;
		}
		return res;
	}
	int BuildFuncDefEType(CplNode *node, FuncInfo* func) {
		cur_func = func;
		int res = 0;
		LocalVarStack_Push();
		// build the arguments' expression type
		for (int i = 0; i < node->Children.size() - 1; i++) {
			auto &iden = node->At(i);
			res |= BuildSingleVarDef(iden);
		}
		res |= BuildNodeEType(node->At(node->Children.size() - 1));
		LocalVarStack_Pop();
		cur_func = nullptr;
		return res;
	}
	int BuildClassDefEType(CplNode* node, ClassInfo* cls) {
		cur_cls = cls;
		int res = 0;
		for (auto child : node->Children) if (child->Type == CplNodeType::FuncDefine) {
			// if child is the node of the __init__ function, then treat it as a global function
			// otherwise, find it in the cls's function map
			bool is_init = false;
			FuncInfo *finfo = nullptr;
			int pos = child->Content.String.find('.');
			if (pos == -1) pos = child->Content.String.size();
			is_init = (child->Content.String.substr(0, pos) == cls->FullName);
			if (is_init) finfo = FindGloablFunction(child->Content.String);
			else finfo = cur_cls->Func[child->Content.String.substr(child->Content.String.find_last_of('@', pos) + 1)];
			res |= BuildFuncDefEType(child, finfo);
		}
		cur_cls = nullptr;
		return res;
	}

	int BuildEType(CplNode* node, NamespaceInfo* nsp) {
		cur_nsp = nsp;
		int res = 0;
		for (auto child : node->Children) {
			switch(child->Type) {
				case CplNodeType::FuncDefine:
					res |= BuildFuncDefEType(child, FindGloablFunction(child->Content.String));
					break;
				case CplNodeType::ClassDefine:
					res |= BuildClassDefEType(child, FindClass(child->Content.String));
					break;
			}
		}
		cur_nsp = nullptr;
		return res;
	}
#pragma endregion
	
	int IdenSystem_LoadDefinition(vector<CplNode*>& roots) {
		int res = 0;
		//build the identifier of all the classes
		for (CplNode *root : roots) {
			for (CplNode *nsp : root->Children) if (nsp->Type == CplNodeType::NamespaceDefine)
				res |= BuildClassIdentifier(nsp);
		}
		//build the content of functions and classes
		for (CplNode *root : roots) {
			//switch a root -> switch the usinglist
			ClearUsing();
			for (CplNode *und : root->Children) if (und->Type == CplNodeType::Using)
				res |= AddUsing(und);
			for (CplNode *nsp : root->Children) if (nsp->Type == CplNodeType::NamespaceDefine)
				res |= BuildDefinition(nsp, CreateNamespace(nsp->Content.String));
		} 
		BuildClassTree(object_cls);
#ifdef DEBUG_MODULE
		PrintNamespaceTree(global_nsp, 0);
		PrintClassTree(object_cls, 0); 
#endif
		return res;
	}

	int IdenSystem_LoadExpressionType(vector<CplNode*>& roots) {
		LocalVarStack_Init();

		int res = 0;
		for (CplNode *root : roots) if (root->Type == CplNodeType::Definition) {
#ifdef DEBUG_MODULE
			for (int i = 0; i < 96; i++) putchar('-');
			putchar('\n');
			// debug_print_cpltree(root, 0);
#endif
			ClearUsing();
			for (CplNode* und : root->Children) if (und->Type == CplNodeType::Using)
				res |= AddUsing(und);
			for (CplNode* nsp : root->Children) if (nsp->Type == CplNodeType::NamespaceDefine) 
				res |= BuildEType(nsp, CreateNamespace(nsp->Content.String));
#ifdef DEBUG_MODULE
			// debug_print_cpltree(root, 0);
#endif
		}
		return 0;
	}

}